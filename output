pid: 00004524
basic block ends with ret
0x4869bb: push 0x9486cfea
0x4869c0: call 0x481348
0x481348: push ecx
0x436418: push ebp
0x436419: push eax
0x41f637: push edi
0x41f63b: pushfd
0x41f640: push ebx
0x41f644: push edx
0x41f64d: push esi
0x41f661: push 0
0x41f68a: mov esi, 0x47fa5f
0x41f68f: mov ebp, esp
0x41f69a: sub esp, 0xc0
0x4620dd: mov ebx, 0x47fa5f
0x4620e6: lea edi, [0x4620e6]
0x4620ec: mov eax, dword ptr [esi]
0x4620f2: lea esi, [esi + 4]
0x4620ff: xor eax, ebx
0x462101: ror eax, 1
0x462104: xor eax, 0x4acb3db9
0x462109: sub eax, 0x458c0140
0x46210e: rol eax, 1
0x462110: xor ebx, eax
0x462117: add edi, eax
0x4323ff: push edi
0x432400: ret
scratch_size: 0x00000000000000C0, scratch_length: 48
start analyzing 4892af
basic block ends with indirect unconditional branch
        0x4892af: movzx eax, byte ptr [esi]
        0x4892b8: lea esi, [esi + 1]
        0x4892be: xor al, bl
        0x4892c3: sub al, 0x3a
        0x4892ce: ror al, 1
        0x4892d1: neg al
        0x4892df: not al
        0x4892ea: xor bl, al
Load [EBP+0x0
        0x4892ef: mov ecx, dword ptr [ebp]
        0x41a261: lea ebp, [ebp + 4]
modifies [x86_sp + 0x2c]
        0x41a267: mov dword ptr [esp + eax], ecx
        0x41a26a: mov eax, dword ptr [esi]
        0x41a26c: add esi, 4
        0x41a273: xor eax, ebx
        0x41a275: ror eax, 1
        0x41a27e: xor eax, 0x4acb3db9
        0x45f79c: sub eax, 0x458c0140
        0x496b0f: rol eax, 1
        0x496b13: xor ebx, eax
        0x474c45: add edi, eax
        0x437e65: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA63 -> 0x000000000047FA68
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 493fb7
basic block ends with ret
        0x493fb7: movzx eax, byte ptr [esi]
        0x493fba: add esi, 1
        0x493fc8: xor al, bl
        0x493fd1: sub al, 0x3a
        0x493fd7: ror al, 1
        0x493fdf: neg al
        0x493fea: not al
        0x493ff2: xor bl, al
Load [EBP+0x0
        0x493ff9: mov ecx, dword ptr [ebp]
        0x494004: lea ebp, [ebp + 4]
modifies [x86_sp + 0x28]
        0x494011: mov dword ptr [esp + eax], ecx
        0x494014: mov eax, dword ptr [esi]
        0x494018: lea esi, [esi + 4]
        0x494022: xor eax, ebx
        0x494024: ror eax, 1
        0x494026: xor eax, 0x4acb3db9
        0x43cb8a: sub eax, 0x458c0140
        0x43cb90: rol eax, 1
        0x43cb93: xor ebx, eax
        0x46688c: add edi, eax
        0x45b9ad: push edi
        0x45b9ae: ret
handlers outputs:
        bytecode: 0x000000000047FA68 -> 0x000000000047FA6D
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 43cebf
basic block ends with indirect unconditional branch
        0x43cebf: movzx eax, byte ptr [esi]
        0x43cec8: lea esi, [esi + 1]
        0x43ced5: xor al, bl
        0x43ced7: sub al, 0x3a
        0x43cede: ror al, 1
        0x43cee0: neg al
        0x43cee6: not al
        0x43ceed: xor bl, al
Load [EBP+0x0
        0x43cef1: mov ecx, dword ptr [ebp]
        0x43cef6: lea ebp, [ebp + 4]
modifies [x86_sp + 0x20]
        0x43cf03: mov dword ptr [esp + eax], ecx
        0x43cf0b: mov eax, dword ptr [esi]
        0x43cf0f: add esi, 4
        0x43cf15: xor eax, ebx
        0x499ae5: ror eax, 1
        0x499ae8: xor eax, 0x4acb3db9
        0x499af4: sub eax, 0x458c0140
        0x499afa: rol eax, 1
        0x499b04: xor ebx, eax
        0x499b07: add edi, eax
        0x499b09: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA6D -> 0x000000000047FA72
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 42eda2
basic block ends with indirect unconditional branch
        0x42eda2: movzx eax, byte ptr [esi]
        0x42edaf: add esi, 1
        0x42edb9: xor al, bl
        0x42edc0: sub al, 0x3a
        0x42edc9: ror al, 1
        0x42edcd: neg al
        0x42edd6: not al
        0x42ede2: xor bl, al
Load [EBP+0x0
        0x42eded: mov ecx, dword ptr [ebp]
        0x42edf1: lea ebp, [ebp + 4]
modifies [x86_sp + 0x30]
        0x42edfe: mov dword ptr [esp + eax], ecx
        0x42ee01: mov eax, dword ptr [esi]
        0x42ee03: lea esi, [esi + 4]
        0x42ee09: xor eax, ebx
        0x42ee0b: ror eax, 1
        0x42ee0e: xor eax, 0x4acb3db9
        0x42ee16: sub eax, 0x458c0140
        0x42ee1b: rol eax, 1
        0x45fda1: xor ebx, eax
        0x45fdab: add edi, eax
        0x449229: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA72 -> 0x000000000047FA77
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 43cc41
basic block ends with ret
        0x43cc41: movzx eax, byte ptr [esi]
        0x43cc4c: add esi, 1
        0x43cc56: xor al, bl
        0x43cc58: sub al, 0x3a
        0x43cc5a: ror al, 1
        0x43cc60: neg al
        0x43cc65: not al
        0x43cc71: xor bl, al
Load [EBP+0x0
        0x43cc7b: mov ecx, dword ptr [ebp]
        0x43cc83: add ebp, 4
modifies [x86_sp + 0x14]
        0x43cc89: mov dword ptr [esp + eax], ecx
        0x43cc8c: mov eax, dword ptr [esi]
        0x44efcd: add esi, 4
        0x41840f: xor eax, ebx
        0x418412: ror eax, 1
        0x41841c: xor eax, 0x4acb3db9
        0x418423: sub eax, 0x458c0140
        0x442e3b: rol eax, 1
        0x442e3d: xor ebx, eax
        0x468e6a: add edi, eax
        0x479987: push edi
        0x479988: ret
handlers outputs:
        bytecode: 0x000000000047FA77 -> 0x000000000047FA7C
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 432085
basic block ends with ret
        0x432085: movzx eax, byte ptr [esi]
        0x43208c: add esi, 1
        0x432096: xor al, bl
        0x43209e: sub al, 0x3a
        0x4320a0: ror al, 1
        0x4320a2: neg al
        0x4320aa: not al
        0x4320b4: xor bl, al
Load [EBP+0x0
        0x4320b6: mov ecx, dword ptr [ebp]
        0x4320bf: add ebp, 4
modifies [x86_sp + 0xc]
        0x4320c5: mov dword ptr [esp + eax], ecx
        0x4320cb: mov eax, dword ptr [esi]
        0x4320cd: add esi, 4
        0x4320de: xor eax, ebx
        0x4320e1: ror eax, 1
        0x4320e3: xor eax, 0x4acb3db9
        0x4320ee: sub eax, 0x458c0140
        0x4320f3: rol eax, 1
        0x4320f5: xor ebx, eax
        0x4320fd: add edi, eax
        0x484226: push edi
        0x484227: ret
handlers outputs:
        bytecode: 0x000000000047FA7C -> 0x000000000047FA81
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 43285a
basic block ends with indirect unconditional branch
        0x43285a: movzx eax, byte ptr [esi]
        0x432866: lea esi, [esi + 1]
        0x432875: xor al, bl
        0x485ae4: sub al, 0x3a
        0x485aed: ror al, 1
        0x485af3: neg al
        0x485af5: not al
        0x485af8: xor bl, al
Load [EBP+0x0
        0x485afa: mov ecx, dword ptr [ebp]
        0x485b01: add ebp, 4
modifies [x86_sp + 0x10]
        0x485b07: mov dword ptr [esp + eax], ecx
        0x485b11: mov eax, dword ptr [esi]
        0x485b16: add esi, 4
        0x485b21: xor eax, ebx
        0x463336: ror eax, 1
        0x463338: xor eax, 0x4acb3db9
        0x46333e: sub eax, 0x458c0140
        0x463344: rol eax, 1
        0x463346: xor ebx, eax
        0x463349: add edi, eax
        0x46334b: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA81 -> 0x000000000047FA86
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 472114
basic block ends with ret
        0x472114: movzx eax, byte ptr [esi]
        0x472118: lea esi, [esi + 1]
        0x472123: xor al, bl
        0x47212d: sub al, 0x3a
        0x472132: ror al, 1
        0x47213a: neg al
        0x47213e: not al
        0x47214c: xor bl, al
Load [EBP+0x0
        0x472151: mov ecx, dword ptr [ebp]
        0x480797: add ebp, 4
modifies [x86_sp + 0x0]
        0x4807a2: mov dword ptr [esp + eax], ecx
        0x4807ac: mov eax, dword ptr [esi]
        0x4807ae: add esi, 4
        0x4807b8: xor eax, ebx
        0x4807bb: ror eax, 1
        0x4807bd: xor eax, 0x4acb3db9
        0x424132: sub eax, 0x458c0140
        0x49accf: rol eax, 1
        0x49acd2: xor ebx, eax
        0x49acd4: add edi, eax
        0x42d599: push edi
        0x42d59a: ret
handlers outputs:
        bytecode: 0x000000000047FA86 -> 0x000000000047FA8B
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 44efa7
basic block ends with indirect unconditional branch
        0x44efa7: movzx eax, byte ptr [esi]
        0x44efae: add esi, 1
        0x430dfd: xor al, bl
        0x430e06: sub al, 0x3a
        0x430e11: ror al, 1
        0x430e13: neg al
        0x430e1a: not al
        0x430e21: xor bl, al
Load [EBP+0x0
        0x430e29: mov ecx, dword ptr [ebp]
        0x430e2d: lea ebp, [ebp + 4]
modifies [x86_sp + 0x4]
        0x430e33: mov dword ptr [esp + eax], ecx
        0x430e3d: mov eax, dword ptr [esi]
        0x430e45: add esi, 4
        0x430e4e: xor eax, ebx
        0x48dca9: ror eax, 1
        0x48dcac: xor eax, 0x4acb3db9
        0x48dcb1: sub eax, 0x458c0140
        0x48dcb8: rol eax, 1
        0x48dcba: xor ebx, eax
        0x48dcc2: add edi, eax
        0x451ade: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA8B -> 0x000000000047FA90
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 47b865
basic block ends with ret
        0x47b865: movzx eax, byte ptr [esi]
        0x47b868: lea esi, [esi + 1]
        0x47b87a: xor al, bl
        0x47b885: sub al, 0x3a
        0x47b889: ror al, 1
        0x47b891: neg al
        0x47b89a: not al
        0x47b8a3: xor bl, al
Load [EBP+0x0
        0x47b8a9: mov ecx, dword ptr [ebp]
        0x47b8ad: lea ebp, [ebp + 4]
modifies [x86_sp + 0x34]
        0x47b8b3: mov dword ptr [esp + eax], ecx
        0x47b8c1: mov eax, dword ptr [esi]
        0x47b8c6: lea esi, [esi + 4]
        0x470fe8: xor eax, ebx
        0x470feb: ror eax, 1
        0x470fed: xor eax, 0x4acb3db9
        0x470ff9: sub eax, 0x458c0140
        0x4348d9: rol eax, 1
        0x4348e2: xor ebx, eax
        0x4348e5: add edi, eax
        0x4348e7: push edi
        0x4348e8: ret
handlers outputs:
        bytecode: 0x000000000047FA90 -> 0x000000000047FA95
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 44489f
basic block ends with ret
        0x44489f: movzx eax, byte ptr [esi]
        0x4448a2: add esi, 1
        0x4448a8: xor al, bl
        0x4448ad: sub al, 0x3a
        0x44c94a: ror al, 1
        0x44c956: neg al
        0x44c95d: not al
        0x44c963: xor bl, al
Load [EBP+0x0
        0x44c96d: mov ecx, dword ptr [ebp]
        0x459689: lea ebp, [ebp + 4]
modifies [x86_sp + 0x34]
        0x459692: mov dword ptr [esp + eax], ecx
        0x45969b: mov eax, dword ptr [esi]
        0x4596a1: lea esi, [esi + 4]
        0x4596a7: xor eax, ebx
        0x4596a9: ror eax, 1
        0x493182: xor eax, 0x4acb3db9
        0x493190: sub eax, 0x458c0140
        0x493197: rol eax, 1
        0x4931a0: xor ebx, eax
        0x435f4f: add edi, eax
        0x469396: push edi
        0x469397: ret
handlers outputs:
        bytecode: 0x000000000047FA95 -> 0x000000000047FA9A
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 441cf6
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x441cf6: movzx eax, byte ptr [esi]
        0x441d02: lea esi, [esi + 1]
        0x441d0f: xor al, bl
        0x441d13: sub al, 0x3a
        0x441d15: ror al, 1
        0x4596b9: neg al
        0x4596c0: not al
        0x4596c2: xor bl, al
Load Scratch:[0x0]
        0x4596cb: mov eax, dword ptr [esp + eax]
        0x4596d2: sub ebp, 4
        0x4596e2: mov dword ptr [ebp], eax
        0x4596ec: mov eax, dword ptr [esi]
        0x4596ee: add esi, 4
        0x4466ea: xor eax, ebx
        0x4466ec: ror eax, 1
        0x4466f3: xor eax, 0x4acb3db9
        0x4466f8: sub eax, 0x458c0140
        0x4466fe: rol eax, 1
        0x446700: xor ebx, eax
        0x446707: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA9A -> 0x000000000047FA9F
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 468429
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x468429: mov eax, ebp
        0x46842e: sub ebp, 4
        0x468437: mov dword ptr [ebp], eax
        0x457104: mov eax, dword ptr [esi]
        0x457108: add esi, 4
        0x45710e: xor eax, ebx
        0x43eed0: ror eax, 1
        0x43eed2: xor eax, 0x4acb3db9
        0x43eedc: sub eax, 0x458c0140
        0x4312e2: rol eax, 1
        0x4312e4: xor ebx, eax
        0x4312e6: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FA9F -> 0x000000000047FAA3
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 4892af
        0x4892af: movzx eax, byte ptr [esi]
        0x4892b8: lea esi, [esi + 1]
        0x4892be: xor al, bl
        0x4892c3: sub al, 0x3a
        0x4892ce: ror al, 1
        0x4892d1: neg al
        0x4892df: not al
        0x4892ea: xor bl, al
Load [EBP+0x0
        0x4892ef: mov ecx, dword ptr [ebp]
        0x41a261: lea ebp, [ebp + 4]
modifies [x86_sp + 0x18]
        0x41a267: mov dword ptr [esp + eax], ecx
        0x41a26a: mov eax, dword ptr [esi]
        0x41a26c: add esi, 4
        0x41a273: xor eax, ebx
        0x41a275: ror eax, 1
        0x41a27e: xor eax, 0x4acb3db9
        0x45f79c: sub eax, 0x458c0140
        0x496b0f: rol eax, 1
        0x496b13: xor ebx, eax
        0x474c45: add edi, eax
        0x437e65: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAA3 -> 0x000000000047FAA8
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 49b6fa
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x49b6fa: mov eax, dword ptr [esi]
        0x49b6fe: lea esi, [esi + 4]
        0x48c6be: xor eax, ebx
        0x48c6c0: lea eax, [eax - 0xc5a392e]
        0x46a251: bswap eax
        0x46a255: neg eax
        0x435c54: not eax
        0x435c56: lea eax, [eax - 0x56865200]
        0x435c60: xor ebx, eax
        0x435c62: lea ebp, [ebp - 4]
        0x435c68: mov dword ptr [ebp], eax
        0x435c71: mov eax, dword ptr [esi]
        0x435c73: lea esi, [esi + 4]
        0x4282ea: xor eax, ebx
        0x464ff9: ror eax, 1
        0x432cb9: xor eax, 0x4acb3db9
        0x432cc1: sub eax, 0x458c0140
        0x432cc6: rol eax, 1
        0x432cc8: xor ebx, eax
        0x432cd5: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAA8 -> 0x000000000047FAB0
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 430855
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x430855: mov eax, ebp
        0x430857: lea ebp, [ebp - 4]
        0x430863: mov dword ptr [ebp], eax
        0x430869: mov eax, dword ptr [esi]
        0x43086b: lea esi, [esi + 4]
        0x430877: xor eax, ebx
        0x43087b: ror eax, 1
        0x43087f: xor eax, 0x4acb3db9
        0x48636e: sub eax, 0x458c0140
        0x478c3b: rol eax, 1
        0x45ecc2: xor ebx, eax
        0x45ecc4: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAB0 -> 0x000000000047FAB4
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 42ae29
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x42ae29: mov eax, dword ptr [esi]
        0x42ae2f: lea esi, [esi + 4]
        0x42ae35: xor eax, ebx
        0x42ae37: sub eax, 0xc5a392e
        0x42ae3f: bswap eax
        0x45a692: neg eax
        0x45a698: not eax
        0x45a69a: lea eax, [eax - 0x56865200]
        0x45a6a0: xor ebx, eax
        0x45a6a4: sub ebp, 4
        0x45a6ac: mov dword ptr [ebp], eax
        0x45a6b5: mov eax, dword ptr [esi]
        0x45a6b9: add esi, 4
        0x45a6bf: xor eax, ebx
        0x45a6c2: ror eax, 1
        0x45a6c7: xor eax, 0x4acb3db9
        0x45a6cd: sub eax, 0x458c0140
        0x4559e7: rol eax, 1
        0x4559ea: xor ebx, eax
        0x4559ec: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAB4 -> 0x000000000047FABC
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 4365af
basic block ends with ret
Load [EBP+0x0
        0x4365af: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x4365c0: mov ecx, dword ptr [ebp + 4]
        0x4365ca: add eax, ecx
        0x4365cc: mov dword ptr [ebp + 4], eax
        0x4365d0: pushfd
        0x4365d2: pop dword ptr [ebp]
        0x4365dc: mov eax, dword ptr [esi]
        0x4365de: add esi, 4
        0x425df6: xor eax, ebx
        0x432133: ror eax, 1
        0x432135: xor eax, 0x4acb3db9
        0x4816d2: sub eax, 0x458c0140
        0x4816d8: rol eax, 1
        0x4816e1: xor ebx, eax
        0x4816e4: add edi, eax
        0x4816e6: push edi
        0x4816e7: ret
handlers outputs:
        bytecode: 0x000000000047FABC -> 0x000000000047FAC0
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 493fb7
        0x493fb7: movzx eax, byte ptr [esi]
        0x493fba: add esi, 1
        0x493fc8: xor al, bl
        0x493fd1: sub al, 0x3a
        0x493fd7: ror al, 1
        0x493fdf: neg al
        0x493fea: not al
        0x493ff2: xor bl, al
Load [EBP+0x0
        0x493ff9: mov ecx, dword ptr [ebp]
        0x494004: lea ebp, [ebp + 4]
modifies [x86_sp + 0x38]
        0x494011: mov dword ptr [esp + eax], ecx
        0x494014: mov eax, dword ptr [esi]
        0x494018: lea esi, [esi + 4]
        0x494022: xor eax, ebx
        0x494024: ror eax, 1
        0x494026: xor eax, 0x4acb3db9
        0x43cb8a: sub eax, 0x458c0140
        0x43cb90: rol eax, 1
        0x43cb93: xor ebx, eax
        0x46688c: add edi, eax
        0x45b9ad: push edi
        0x45b9ae: ret
handlers outputs:
        bytecode: 0x000000000047FAC0 -> 0x000000000047FAC5
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 46e225
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x46e225: mov eax, ebp
        0x4376a2: lea ebp, [ebp - 4]
        0x4376a8: mov dword ptr [ebp], eax
        0x4376b3: mov eax, dword ptr [esi]
        0x4376b5: add esi, 4
        0x417f2d: xor eax, ebx
        0x417f2f: ror eax, 1
        0x417f35: xor eax, 0x4acb3db9
        0x491b9d: sub eax, 0x458c0140
        0x4921f9: rol eax, 1
        0x4921fe: xor ebx, eax
        0x492201: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAC5 -> 0x000000000047FAC9
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 4762b1
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x4762b1: mov eax, dword ptr [esi]
        0x4762bb: lea esi, [esi + 4]
        0x4762c2: xor eax, ebx
        0x4762c5: lea eax, [eax - 0xc5a392e]
        0x4762d0: bswap eax
        0x4762d9: neg eax
        0x4762db: not eax
        0x4762de: lea eax, [eax - 0x56865200]
        0x4762e6: xor ebx, eax
        0x4762ee: sub ebp, 4
        0x4762f5: mov dword ptr [ebp], eax
        0x476303: mov eax, dword ptr [esi]
        0x476305: lea esi, [esi + 4]
        0x476312: xor eax, ebx
        0x476316: ror eax, 1
        0x476318: xor eax, 0x4acb3db9
        0x476320: sub eax, 0x458c0140
        0x476325: rol eax, 1
        0x42287e: xor ebx, eax
        0x422886: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAC9 -> 0x000000000047FAD1
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 423f22
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x423f22: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x423f26: mov ecx, dword ptr [ebp + 4]
        0x423f30: add eax, ecx
        0x45fb92: mov dword ptr [ebp + 4], eax
        0x45fb99: pushfd
        0x45fb9f: pop dword ptr [ebp]
        0x45fba8: mov eax, dword ptr [esi]
        0x46bef8: add esi, 4
        0x46bf0a: xor eax, ebx
        0x417c99: ror eax, 1
        0x417c9c: xor eax, 0x4acb3db9
        0x417ca9: sub eax, 0x458c0140
        0x417cae: rol eax, 1
        0x417cb3: xor ebx, eax
        0x417cb6: add edi, eax
        0x48e13d: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAD1 -> 0x000000000047FAD5
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 43cebf
        0x43cebf: movzx eax, byte ptr [esi]
        0x43cec8: lea esi, [esi + 1]
        0x43ced5: xor al, bl
        0x43ced7: sub al, 0x3a
        0x43cede: ror al, 1
        0x43cee0: neg al
        0x43cee6: not al
        0x43ceed: xor bl, al
Load [EBP+0x0
        0x43cef1: mov ecx, dword ptr [ebp]
        0x43cef6: lea ebp, [ebp + 4]
modifies [x86_sp + 0x38]
        0x43cf03: mov dword ptr [esp + eax], ecx
        0x43cf0b: mov eax, dword ptr [esi]
        0x43cf0f: add esi, 4
        0x43cf15: xor eax, ebx
        0x499ae5: ror eax, 1
        0x499ae8: xor eax, 0x4acb3db9
        0x499af4: sub eax, 0x458c0140
        0x499afa: rol eax, 1
        0x499b04: xor ebx, eax
        0x499b07: add edi, eax
        0x499b09: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAD5 -> 0x000000000047FADA
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 463fb4
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x463fb4: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x463fbf: mov ecx, dword ptr [ebp + 4]
        0x463fc8: not eax
        0x463fca: not ecx
        0x463fcc: and eax, ecx
        0x425d17: mov dword ptr [ebp + 4], eax
        0x425d1d: pushfd
        0x425d29: pop dword ptr [ebp]
        0x425d2d: mov eax, dword ptr [esi]
        0x425d32: lea esi, [esi + 4]
        0x425d38: xor eax, ebx
        0x425d3b: ror eax, 1
        0x425d3d: xor eax, 0x4acb3db9
        0x425d45: sub eax, 0x458c0140
        0x425d4b: rol eax, 1
        0x425d4d: xor ebx, eax
        0x425d4f: add edi, eax
        0x47a346: jmp edi
handlers outputs:
        bytecode: 0x000000000047FADA -> 0x000000000047FADE
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 42eda2
        0x42eda2: movzx eax, byte ptr [esi]
        0x42edaf: add esi, 1
        0x42edb9: xor al, bl
        0x42edc0: sub al, 0x3a
        0x42edc9: ror al, 1
        0x42edcd: neg al
        0x42edd6: not al
        0x42ede2: xor bl, al
Load [EBP+0x0
        0x42eded: mov ecx, dword ptr [ebp]
        0x42edf1: lea ebp, [ebp + 4]
modifies [x86_sp + 0x24]
        0x42edfe: mov dword ptr [esp + eax], ecx
        0x42ee01: mov eax, dword ptr [esi]
        0x42ee03: lea esi, [esi + 4]
        0x42ee09: xor eax, ebx
        0x42ee0b: ror eax, 1
        0x42ee0e: xor eax, 0x4acb3db9
        0x42ee16: sub eax, 0x458c0140
        0x42ee1b: rol eax, 1
        0x45fda1: xor ebx, eax
        0x45fdab: add edi, eax
        0x449229: jmp edi
handlers outputs:
        bytecode: 0x000000000047FADE -> 0x000000000047FAE3
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 496c89
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x496c89: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x496c8d: mov ecx, dword ptr [ebp + 4]
        0x496c9a: add eax, ecx
        0x46be0f: mov dword ptr [ebp + 4], eax
        0x46be17: pushfd
        0x46be1b: pop dword ptr [ebp]
        0x46be21: mov eax, dword ptr [esi]
        0x46be24: add esi, 4
        0x46be2f: xor eax, ebx
        0x4539dc: ror eax, 1
        0x4539e1: xor eax, 0x4acb3db9
        0x4539e6: sub eax, 0x458c0140
        0x439d01: rol eax, 1
        0x439d04: xor ebx, eax
        0x439d0b: add edi, eax
        0x492ae3: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAE3 -> 0x000000000047FAE7
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 43cc41
        0x43cc41: movzx eax, byte ptr [esi]
        0x43cc4c: add esi, 1
        0x43cc56: xor al, bl
        0x43cc58: sub al, 0x3a
        0x43cc5a: ror al, 1
        0x43cc60: neg al
        0x43cc65: not al
        0x43cc71: xor bl, al
Load [EBP+0x0
        0x43cc7b: mov ecx, dword ptr [ebp]
        0x43cc83: add ebp, 4
modifies [x86_sp + 0x24]
        0x43cc89: mov dword ptr [esp + eax], ecx
        0x43cc8c: mov eax, dword ptr [esi]
        0x44efcd: add esi, 4
        0x41840f: xor eax, ebx
        0x418412: ror eax, 1
        0x41841c: xor eax, 0x4acb3db9
        0x418423: sub eax, 0x458c0140
        0x442e3b: rol eax, 1
        0x442e3d: xor ebx, eax
        0x468e6a: add edi, eax
        0x479987: push edi
        0x479988: ret
handlers outputs:
        bytecode: 0x000000000047FAE7 -> 0x000000000047FAEC
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 45b420
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x45b420: mov eax, ebp
        0x45b426: lea ebp, [ebp - 4]
        0x427245: mov dword ptr [ebp], eax
        0x427251: mov eax, dword ptr [esi]
        0x42725b: add esi, 4
        0x427269: xor eax, ebx
        0x42726b: ror eax, 1
        0x427271: xor eax, 0x4acb3db9
        0x427276: sub eax, 0x458c0140
        0x42727b: rol eax, 1
        0x42727d: xor ebx, eax
        0x42727f: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAEC -> 0x000000000047FAF0
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 4451ce
basic block ends with ret
Load [EBP+0x0
        0x4451ce: mov ecx, dword ptr [ebp]
Deref(t32,ss)
        0x4451d9: mov eax, dword ptr ss:[ecx]
        0x4451e2: mov dword ptr [ebp], eax
        0x4451eb: mov eax, dword ptr [esi]
        0x4451ed: add esi, 4
        0x4451f9: xor eax, ebx
        0x4451fb: ror eax, 1
        0x445203: xor eax, 0x4acb3db9
        0x445208: sub eax, 0x458c0140
        0x455fdb: rol eax, 1
        0x455fdd: xor ebx, eax
        0x455fdf: add edi, eax
        0x423edf: push edi
        0x423ee0: ret
handlers outputs:
        bytecode: 0x000000000047FAF0 -> 0x000000000047FAF4
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 47e3ff
basic block ends with ret
Load [EBP+0x0
        0x47e3ff: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x47e403: mov ecx, dword ptr [ebp + 4]
        0x47e40b: not eax
        0x45700b: not ecx
        0x457011: and eax, ecx
        0x457013: mov dword ptr [ebp + 4], eax
        0x45701a: pushfd
        0x45701b: pop dword ptr [ebp]
        0x457026: mov eax, dword ptr [esi]
        0x45702a: add esi, 4
        0x425c9d: xor eax, ebx
        0x425c9f: ror eax, 1
        0x425ca1: xor eax, 0x4acb3db9
        0x425ca8: sub eax, 0x458c0140
        0x425caf: rol eax, 1
        0x425cb4: xor ebx, eax
        0x425cbe: add edi, eax
        0x4545f7: push edi
        0x4545f8: ret
handlers outputs:
        bytecode: 0x000000000047FAF4 -> 0x000000000047FAF8
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 432085
        0x432085: movzx eax, byte ptr [esi]
        0x43208c: add esi, 1
        0x432096: xor al, bl
        0x43209e: sub al, 0x3a
        0x4320a0: ror al, 1
        0x4320a2: neg al
        0x4320aa: not al
        0x4320b4: xor bl, al
Load [EBP+0x0
        0x4320b6: mov ecx, dword ptr [ebp]
        0x4320bf: add ebp, 4
modifies [x86_sp + 0x8]
        0x4320c5: mov dword ptr [esp + eax], ecx
        0x4320cb: mov eax, dword ptr [esi]
        0x4320cd: add esi, 4
        0x4320de: xor eax, ebx
        0x4320e1: ror eax, 1
        0x4320e3: xor eax, 0x4acb3db9
        0x4320ee: sub eax, 0x458c0140
        0x4320f3: rol eax, 1
        0x4320f5: xor ebx, eax
        0x4320fd: add edi, eax
        0x484226: push edi
        0x484227: ret
handlers outputs:
        bytecode: 0x000000000047FAF8 -> 0x000000000047FAFD
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 49879b
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x49879b: mov ebp, dword ptr [ebp]
        0x4987a9: mov eax, dword ptr [esi]
        0x44e529: add esi, 4
        0x44e530: xor eax, ebx
        0x44e533: ror eax, 1
        0x44e539: xor eax, 0x4acb3db9
        0x44e53f: sub eax, 0x458c0140
        0x44e545: rol eax, 1
        0x44e548: xor ebx, eax
        0x44e553: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FAFD -> 0x000000000047FB01
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 437794
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x437794: movzx eax, byte ptr [esi]
        0x437799: lea esi, [esi + 1]
        0x4377a7: xor al, bl
        0x4377aa: sub al, 0x3a
        0x4377ad: ror al, 1
        0x4377b3: neg al
        0x4377b5: not al
        0x4377bd: xor bl, al
Load Scratch:[0x24]
        0x4377c1: mov eax, dword ptr [esp + eax]
        0x4502ef: lea ebp, [ebp - 4]
        0x4502f5: mov dword ptr [ebp], eax
        0x4502f9: mov eax, dword ptr [esi]
        0x4502fe: add esi, 4
        0x450305: xor eax, ebx
        0x450308: ror eax, 1
        0x45030a: xor eax, 0x4acb3db9
        0x450310: sub eax, 0x458c0140
        0x449794: rol eax, 1
        0x4497a0: xor ebx, eax
        0x4497a2: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB01 -> 0x000000000047FB06
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 438038
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x438038: movzx eax, byte ptr [esi]
        0x43803c: add esi, 1
        0x438042: xor al, bl
        0x438046: sub al, 0x3a
        0x438049: ror al, 1
        0x43804e: neg al
        0x438056: not al
        0x43805a: xor bl, al
Load Scratch:[0x24]
        0x43805f: mov eax, dword ptr [esp + eax]
        0x438067: lea ebp, [ebp - 4]
        0x43806f: mov dword ptr [ebp], eax
        0x438073: mov eax, dword ptr [esi]
        0x460d5b: add esi, 4
        0x460d61: xor eax, ebx
        0x460d65: ror eax, 1
        0x460d6e: xor eax, 0x4acb3db9
        0x481c3e: sub eax, 0x458c0140
        0x481c43: rol eax, 1
        0x481c46: xor ebx, eax
        0x481c48: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB06 -> 0x000000000047FB0B
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 487b17
basic block ends with ret
Load [EBP+0x0
        0x487b17: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x487b1b: mov ecx, dword ptr [ebp + 4]
        0x487b21: not eax
        0x460771: not ecx
        0x460774: and eax, ecx
        0x460485: mov dword ptr [ebp + 4], eax
        0x46048a: pushfd
        0x46048b: pop dword ptr [ebp]
        0x460496: mov eax, dword ptr [esi]
        0x46049e: add esi, 4
        0x431c55: xor eax, ebx
        0x431c57: ror eax, 1
        0x431c5b: xor eax, 0x4acb3db9
        0x431c65: sub eax, 0x458c0140
        0x431c6b: rol eax, 1
        0x4724f5: xor ebx, eax
        0x4724f7: add edi, eax
        0x4681f6: push edi
        0x4681f7: ret
handlers outputs:
        bytecode: 0x000000000047FB0B -> 0x000000000047FB0F
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 43285a
        0x43285a: movzx eax, byte ptr [esi]
        0x432866: lea esi, [esi + 1]
        0x432875: xor al, bl
        0x485ae4: sub al, 0x3a
        0x485aed: ror al, 1
        0x485af3: neg al
        0x485af5: not al
        0x485af8: xor bl, al
Load [EBP+0x0
        0x485afa: mov ecx, dword ptr [ebp]
        0x485b01: add ebp, 4
modifies [x86_sp + 0x38]
        0x485b07: mov dword ptr [esp + eax], ecx
        0x485b11: mov eax, dword ptr [esi]
        0x485b16: add esi, 4
        0x485b21: xor eax, ebx
        0x463336: ror eax, 1
        0x463338: xor eax, 0x4acb3db9
        0x46333e: sub eax, 0x458c0140
        0x463344: rol eax, 1
        0x463346: xor ebx, eax
        0x463349: add edi, eax
        0x46334b: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB0F -> 0x000000000047FB14
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 49afdf
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x49afdf: mov eax, dword ptr [esi]
        0x49afe2: add esi, 4
        0x49afe9: xor eax, ebx
        0x49afef: sub eax, 0xc5a392e
        0x49aff4: bswap eax
        0x49aff6: neg eax
        0x49affb: not eax
        0x49b002: lea eax, [eax - 0x56865200]
        0x445128: xor ebx, eax
        0x445130: sub ebp, 4
        0x445142: mov dword ptr [ebp], eax
        0x44514a: mov eax, dword ptr [esi]
        0x44514c: lea esi, [esi + 4]
        0x445152: xor eax, ebx
        0x43aa78: ror eax, 1
        0x43aa7a: xor eax, 0x4acb3db9
        0x43aa80: sub eax, 0x458c0140
        0x43aa85: rol eax, 1
        0x43aa8e: xor ebx, eax
        0x43771b: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB14 -> 0x000000000047FB1C
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 45c2f6
basic block ends with ret
Load [EBP+0x0
        0x45c2f6: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x45c2fa: mov ecx, dword ptr [ebp + 4]
        0x45c304: not eax
        0x45c306: not ecx
        0x45c308: and eax, ecx
        0x466256: mov dword ptr [ebp + 4], eax
        0x46625d: pushfd
        0x466263: pop dword ptr [ebp]
        0x46626f: mov eax, dword ptr [esi]
        0x466271: add esi, 4
        0x466279: xor eax, ebx
        0x46627b: ror eax, 1
        0x46627d: xor eax, 0x4acb3db9
        0x466284: sub eax, 0x458c0140
        0x466289: rol eax, 1
        0x46628f: xor ebx, eax
        0x466294: add edi, eax
        0x466296: push edi
        0x466297: ret
handlers outputs:
        bytecode: 0x000000000047FB1C -> 0x000000000047FB20
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 472114
        0x472114: movzx eax, byte ptr [esi]
        0x472118: lea esi, [esi + 1]
        0x472123: xor al, bl
        0x47212d: sub al, 0x3a
        0x472132: ror al, 1
        0x47213a: neg al
        0x47213e: not al
        0x47214c: xor bl, al
Load [EBP+0x0
        0x472151: mov ecx, dword ptr [ebp]
        0x480797: add ebp, 4
modifies [x86_sp + 0x1c]
        0x4807a2: mov dword ptr [esp + eax], ecx
        0x4807ac: mov eax, dword ptr [esi]
        0x4807ae: add esi, 4
        0x4807b8: xor eax, ebx
        0x4807bb: ror eax, 1
        0x4807bd: xor eax, 0x4acb3db9
        0x424132: sub eax, 0x458c0140
        0x49accf: rol eax, 1
        0x49acd2: xor ebx, eax
        0x49acd4: add edi, eax
        0x42d599: push edi
        0x42d59a: ret
handlers outputs:
        bytecode: 0x000000000047FB20 -> 0x000000000047FB25
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 43fc2a
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x43fc2a: movzx eax, byte ptr [esi]
        0x43fc2f: lea esi, [esi + 1]
        0x43fc35: xor al, bl
        0x43fc3f: sub al, 0x3a
        0x43fc42: ror al, 1
        0x43fc44: neg al
        0x43fc4e: not al
        0x43fc54: xor bl, al
Load Scratch:[0x8]
        0x43fc57: mov eax, dword ptr [esp + eax]
        0x486f37: lea ebp, [ebp - 4]
        0x486f3d: mov dword ptr [ebp], eax
        0x486f41: mov eax, dword ptr [esi]
        0x486f46: add esi, 4
        0x486f4c: xor eax, ebx
        0x486f4e: ror eax, 1
        0x486f51: xor eax, 0x4acb3db9
        0x486f5d: sub eax, 0x458c0140
        0x486f63: rol eax, 1
        0x486f65: xor ebx, eax
        0x486f6d: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB25 -> 0x000000000047FB2A
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 45b7ef
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x45b7ef: movzx eax, byte ptr [esi]
        0x45b7f6: add esi, 1
        0x45b800: xor al, bl
        0x45b802: sub al, 0x3a
        0x45b805: ror al, 1
        0x45b810: neg al
        0x45b812: not al
        0x45b81a: xor bl, al
Load Scratch:[0x8]
        0x45b81c: mov eax, dword ptr [esp + eax]
        0x45b826: lea ebp, [ebp - 4]
        0x42f000: mov dword ptr [ebp], eax
        0x42f004: mov eax, dword ptr [esi]
        0x42f007: lea esi, [esi + 4]
        0x42f00f: xor eax, ebx
        0x483e22: ror eax, 1
        0x483e26: xor eax, 0x4acb3db9
        0x483e2b: sub eax, 0x458c0140
        0x483e30: rol eax, 1
        0x483e32: xor ebx, eax
        0x483e3b: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB2A -> 0x000000000047FB2F
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 43c7e5
basic block ends with ret
Load [EBP+0x0
        0x43c7e5: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x43c7eb: mov ecx, dword ptr [ebp + 4]
        0x43c7f3: not eax
        0x43c7f5: not ecx
        0x43d1af: and eax, ecx
        0x43d1b1: mov dword ptr [ebp + 4], eax
        0x43d1b8: pushfd
        0x43d1b9: pop dword ptr [ebp]
        0x43d1c2: mov eax, dword ptr [esi]
        0x43d1cb: lea esi, [esi + 4]
        0x4662af: xor eax, ebx
        0x43d290: ror eax, 1
        0x43d294: xor eax, 0x4acb3db9
        0x43d29f: sub eax, 0x458c0140
        0x43d2a5: rol eax, 1
        0x43d2aa: xor ebx, eax
        0x43d2ac: add edi, eax
        0x437ae0: push edi
        0x437ae1: ret
handlers outputs:
        bytecode: 0x000000000047FB2F -> 0x000000000047FB33
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 44efa7
        0x44efa7: movzx eax, byte ptr [esi]
        0x44efae: add esi, 1
        0x430dfd: xor al, bl
        0x430e06: sub al, 0x3a
        0x430e11: ror al, 1
        0x430e13: neg al
        0x430e1a: not al
        0x430e21: xor bl, al
Load [EBP+0x0
        0x430e29: mov ecx, dword ptr [ebp]
        0x430e2d: lea ebp, [ebp + 4]
modifies [x86_sp + 0x38]
        0x430e33: mov dword ptr [esp + eax], ecx
        0x430e3d: mov eax, dword ptr [esi]
        0x430e45: add esi, 4
        0x430e4e: xor eax, ebx
        0x48dca9: ror eax, 1
        0x48dcac: xor eax, 0x4acb3db9
        0x48dcb1: sub eax, 0x458c0140
        0x48dcb8: rol eax, 1
        0x48dcba: xor ebx, eax
        0x48dcc2: add edi, eax
        0x451ade: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB33 -> 0x000000000047FB38
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 441472
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x441472: mov eax, dword ptr [esi]
        0x441479: add esi, 4
        0x441481: xor eax, ebx
        0x441483: lea eax, [eax - 0xc5a392e]
        0x44148e: bswap eax
        0x441497: neg eax
        0x441499: not eax
        0x44149e: lea eax, [eax - 0x56865200]
        0x4414a5: xor ebx, eax
        0x4414a7: sub ebp, 4
        0x44b92d: mov dword ptr [ebp], eax
        0x44b939: mov eax, dword ptr [esi]
        0x44b93b: add esi, 4
        0x44b941: xor eax, ebx
        0x44b944: ror eax, 1
        0x44b94c: xor eax, 0x4acb3db9
        0x44b951: sub eax, 0x458c0140
        0x44b956: rol eax, 1
        0x44b958: xor ebx, eax
        0x44ceee: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB38 -> 0x000000000047FB40
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 44c4d5
basic block ends with ret
Load [EBP+0x0
        0x44c4d5: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x44c4db: mov ecx, dword ptr [ebp + 4]
        0x44c4e0: not eax
        0x44c4e2: not ecx
        0x44c4e5: and eax, ecx
        0x4539c2: mov dword ptr [ebp + 4], eax
        0x4539c6: pushfd
        0x4539cc: pop dword ptr [ebp]
        0x47fff7: mov eax, dword ptr [esi]
        0x480000: add esi, 4
        0x48000a: xor eax, ebx
        0x48000c: ror eax, 1
        0x48000f: xor eax, 0x4acb3db9
        0x480014: sub eax, 0x458c0140
        0x480019: rol eax, 1
        0x48001b: xor ebx, eax
        0x48001d: add edi, eax
        0x48001f: push edi
        0x480020: ret
handlers outputs:
        bytecode: 0x000000000047FB40 -> 0x000000000047FB44
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 47b865
        0x47b865: movzx eax, byte ptr [esi]
        0x47b868: lea esi, [esi + 1]
        0x47b87a: xor al, bl
        0x47b885: sub al, 0x3a
        0x47b889: ror al, 1
        0x47b891: neg al
        0x47b89a: not al
        0x47b8a3: xor bl, al
Load [EBP+0x0
        0x47b8a9: mov ecx, dword ptr [ebp]
        0x47b8ad: lea ebp, [ebp + 4]
modifies [x86_sp + 0x1c]
        0x47b8b3: mov dword ptr [esp + eax], ecx
        0x47b8c1: mov eax, dword ptr [esi]
        0x47b8c6: lea esi, [esi + 4]
        0x470fe8: xor eax, ebx
        0x470feb: ror eax, 1
        0x470fed: xor eax, 0x4acb3db9
        0x470ff9: sub eax, 0x458c0140
        0x4348d9: rol eax, 1
        0x4348e2: xor ebx, eax
        0x4348e5: add edi, eax
        0x4348e7: push edi
        0x4348e8: ret
handlers outputs:
        bytecode: 0x000000000047FB44 -> 0x000000000047FB49
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 42e0d5
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x42e0d5: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x42e0de: mov ecx, dword ptr [ebp + 4]
        0x42e0e4: add eax, ecx
        0x43ad11: mov dword ptr [ebp + 4], eax
        0x43ad16: pushfd
        0x43ad1f: pop dword ptr [ebp]
        0x43ad29: mov eax, dword ptr [esi]
        0x43ad2c: lea esi, [esi + 4]
        0x46e6c2: xor eax, ebx
        0x46e6c4: ror eax, 1
        0x46e6cc: xor eax, 0x4acb3db9
        0x46e6d1: sub eax, 0x458c0140
        0x426ff4: rol eax, 1
        0x486409: xor ebx, eax
        0x48640b: add edi, eax
        0x48640d: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB49 -> 0x000000000047FB4D
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 44489f
        0x44489f: movzx eax, byte ptr [esi]
        0x4448a2: add esi, 1
        0x4448a8: xor al, bl
        0x4448ad: sub al, 0x3a
        0x44c94a: ror al, 1
        0x44c956: neg al
        0x44c95d: not al
        0x44c963: xor bl, al
Load [EBP+0x0
        0x44c96d: mov ecx, dword ptr [ebp]
        0x459689: lea ebp, [ebp + 4]
modifies [x86_sp + 0x3c]
        0x459692: mov dword ptr [esp + eax], ecx
        0x45969b: mov eax, dword ptr [esi]
        0x4596a1: lea esi, [esi + 4]
        0x4596a7: xor eax, ebx
        0x4596a9: ror eax, 1
        0x493182: xor eax, 0x4acb3db9
        0x493190: sub eax, 0x458c0140
        0x493197: rol eax, 1
        0x4931a0: xor ebx, eax
        0x435f4f: add edi, eax
        0x469396: push edi
        0x469397: ret
handlers outputs:
        bytecode: 0x000000000047FB4D -> 0x000000000047FB52
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 4892af
        0x4892af: movzx eax, byte ptr [esi]
        0x4892b8: lea esi, [esi + 1]
        0x4892be: xor al, bl
        0x4892c3: sub al, 0x3a
        0x4892ce: ror al, 1
        0x4892d1: neg al
        0x4892df: not al
        0x4892ea: xor bl, al
Load [EBP+0x0
        0x4892ef: mov ecx, dword ptr [ebp]
        0x41a261: lea ebp, [ebp + 4]
modifies [x86_sp + 0x14]
        0x41a267: mov dword ptr [esp + eax], ecx
        0x41a26a: mov eax, dword ptr [esi]
        0x41a26c: add esi, 4
        0x41a273: xor eax, ebx
        0x41a275: ror eax, 1
        0x41a27e: xor eax, 0x4acb3db9
        0x45f79c: sub eax, 0x458c0140
        0x496b0f: rol eax, 1
        0x496b13: xor ebx, eax
        0x474c45: add edi, eax
        0x437e65: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB52 -> 0x000000000047FB57
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 4786ff
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x4786ff: movzx eax, byte ptr [esi]
        0x478708: lea esi, [esi + 1]
        0x478714: xor al, bl
        0x450d2c: sub al, 0x3a
        0x450d2f: ror al, 1
        0x450d34: neg al
        0x450d36: not al
        0x450d38: xor bl, al
Load Scratch:[0x28]
        0x450d3b: mov eax, dword ptr [esp + eax]
        0x450d43: lea ebp, [ebp - 4]
        0x446f80: mov dword ptr [ebp], eax
        0x446f84: mov eax, dword ptr [esi]
        0x446f86: lea esi, [esi + 4]
        0x446f93: xor eax, ebx
        0x446f96: ror eax, 1
        0x446f99: xor eax, 0x4acb3db9
        0x446fa7: sub eax, 0x458c0140
        0x446fac: rol eax, 1
        0x446fb3: xor ebx, eax
        0x446fb5: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB57 -> 0x000000000047FB5C
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 43a136
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x43a136: mov eax, dword ptr [esi]
        0x43a13c: lea esi, [esi + 4]
        0x43a148: xor eax, ebx
        0x43a14f: lea eax, [eax - 0xc5a392e]
        0x43a155: bswap eax
        0x43b641: neg eax
        0x417b57: not eax
        0x417b5c: lea eax, [eax - 0x56865200]
        0x43d911: xor ebx, eax
        0x43d913: sub ebp, 4
        0x43d91c: mov dword ptr [ebp], eax
        0x43d924: mov eax, dword ptr [esi]
        0x43d926: lea esi, [esi + 4]
        0x43d933: xor eax, ebx
        0x43d935: ror eax, 1
        0x43d938: xor eax, 0x4acb3db9
        0x43d942: sub eax, 0x458c0140
        0x43d947: rol eax, 1
        0x43d950: xor ebx, eax
        0x43d952: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB5C -> 0x000000000047FB64
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 45b707
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x45b707: movzx eax, byte ptr [esi]
        0x45b70a: lea esi, [esi + 1]
        0x45b710: xor al, bl
        0x45b712: sub al, 0x3a
        0x45b715: ror al, 1
        0x45b717: neg al
        0x45b71c: not al
        0x45b71e: xor bl, al
Load Scratch:[0x2c]
        0x45b722: mov eax, dword ptr [esp + eax]
        0x45b725: sub ebp, 4
        0x45b72f: mov dword ptr [ebp], eax
        0x44f254: mov eax, dword ptr [esi]
        0x44f25f: lea esi, [esi + 4]
        0x44f265: xor eax, ebx
        0x44f267: ror eax, 1
        0x44f269: xor eax, 0x4acb3db9
        0x44f26e: sub eax, 0x458c0140
        0x477b82: rol eax, 1
        0x477b84: xor ebx, eax
        0x477b87: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB64 -> 0x000000000047FB69
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 49af2e
basic block ends with ret
Load [EBP+0x0
        0x49af2e: mov eax, dword ptr [ebp]
Load [EBP+0x4
        0x49af36: mov ecx, dword ptr [ebp + 4]
        0x49af3a: add eax, ecx
        0x481a8f: mov dword ptr [ebp + 4], eax
        0x481a96: pushfd
        0x481a97: pop dword ptr [ebp]
        0x481a9f: mov eax, dword ptr [esi]
        0x481aa3: add esi, 4
        0x481ab1: xor eax, ebx
        0x481ab4: ror eax, 1
        0x49b032: xor eax, 0x4acb3db9
        0x49b039: sub eax, 0x458c0140
        0x49b03e: rol eax, 1
        0x49b049: xor ebx, eax
        0x49b04c: add edi, eax
        0x49b254: push edi
        0x49b255: ret
handlers outputs:
        bytecode: 0x000000000047FB69 -> 0x000000000047FB6D
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 493fb7
        0x493fb7: movzx eax, byte ptr [esi]
        0x493fba: add esi, 1
        0x493fc8: xor al, bl
        0x493fd1: sub al, 0x3a
        0x493fd7: ror al, 1
        0x493fdf: neg al
        0x493fea: not al
        0x493ff2: xor bl, al
Load [EBP+0x0
        0x493ff9: mov ecx, dword ptr [ebp]
        0x494004: lea ebp, [ebp + 4]
modifies [x86_sp + 0x38]
        0x494011: mov dword ptr [esp + eax], ecx
        0x494014: mov eax, dword ptr [esi]
        0x494018: lea esi, [esi + 4]
        0x494022: xor eax, ebx
        0x494024: ror eax, 1
        0x494026: xor eax, 0x4acb3db9
        0x43cb8a: sub eax, 0x458c0140
        0x43cb90: rol eax, 1
        0x43cb93: xor ebx, eax
        0x46688c: add edi, eax
        0x45b9ad: push edi
        0x45b9ae: ret
handlers outputs:
        bytecode: 0x000000000047FB6D -> 0x000000000047FB72
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001004
done.



start analyzing 475039
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x475039: mov eax, dword ptr [esi]
        0x47503b: lea esi, [esi + 4]
        0x475042: xor eax, ebx
        0x475045: lea eax, [eax - 0xc5a392e]
        0x47504c: bswap eax
        0x475053: neg eax
        0x475056: not eax
        0x475059: lea eax, [eax - 0x56865200]
        0x47505f: xor ebx, eax
        0x447aeb: lea ebp, [ebp - 4]
        0x447af1: mov dword ptr [ebp], eax
        0x447b02: mov eax, dword ptr [esi]
        0x44fcfb: add esi, 4
        0x44fd0a: xor eax, ebx
        0x453a88: ror eax, 1
        0x453a8f: xor eax, 0x4acb3db9
        0x453a96: sub eax, 0x458c0140
        0x453a9c: rol eax, 1
        0x453a9e: xor ebx, eax
        0x453aa2: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB72 -> 0x000000000047FB7A
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 480201
basic block ends with indirect unconditional branch
Load [EBP+0x0
        0x480201: mov ecx, dword ptr [ebp]
Deref(t81,unknown)
        0x480205: mov eax, dword ptr [ecx]
        0x48020d: mov dword ptr [ebp], eax
        0x480214: mov eax, dword ptr [esi]
        0x477e50: lea esi, [esi + 4]
        0x477e5a: xor eax, ebx
        0x477e5c: ror eax, 1
        0x477e63: xor eax, 0x4acb3db9
        0x477e72: sub eax, 0x458c0140
        0x477e79: rol eax, 1
        0x477e7f: xor ebx, eax
        0x477e82: add edi, eax
        0x4968ed: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB7A -> 0x000000000047FB7E
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000001000
done.



start analyzing 41d8ad
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x41d8ad: movzx eax, byte ptr [esi]
        0x41d8b3: lea esi, [esi + 1]
        0x41d8bf: xor al, bl
        0x41d8c8: sub al, 0x3a
        0x41d8ca: ror al, 1
        0x41703e: neg al
        0x417040: not al
        0x417042: xor bl, al
Load Scratch:[0x4]
        0x417045: mov eax, dword ptr [esp + eax]
        0x41704b: sub ebp, 4
        0x417051: mov dword ptr [ebp], eax
        0x41705a: mov eax, dword ptr [esi]
        0x41705c: lea esi, [esi + 4]
        0x41706e: xor eax, ebx
        0x417072: ror eax, 1
        0x41707a: xor eax, 0x4acb3db9
        0x417083: sub eax, 0x458c0140
        0x417089: rol eax, 1
        0x41708b: xor ebx, eax
        0x41708f: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB7E -> 0x000000000047FB83
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 49734a
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x49734a: movzx eax, byte ptr [esi]
        0x49734f: lea esi, [esi + 1]
        0x49735c: xor al, bl
        0x497362: sub al, 0x3a
        0x497365: ror al, 1
        0x49736b: neg al
        0x497371: not al
        0x497374: xor bl, al
Load Scratch:[0x18]
        0x497378: mov eax, dword ptr [esp + eax]
        0x4589fa: sub ebp, 4
        0x44f6d3: mov dword ptr [ebp], eax
        0x44f6df: mov eax, dword ptr [esi]
        0x44f6e5: add esi, 4
        0x48ff08: xor eax, ebx
        0x48ff0a: ror eax, 1
        0x48ff0c: xor eax, 0x4acb3db9
        0x48ff14: sub eax, 0x458c0140
        0x48ff1a: rol eax, 1
        0x48ff1f: xor ebx, eax
        0x48ff21: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB83 -> 0x000000000047FB88
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 44fa7a
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x44fa7a: movzx eax, byte ptr [esi]
        0x44fa7d: add esi, 1
        0x44fa83: xor al, bl
        0x44fa8b: sub al, 0x3a
        0x44fa8d: ror al, 1
        0x44fa8f: neg al
        0x4795de: not al
        0x4795e2: xor bl, al
Load Scratch:[0x10]
        0x4795e9: mov eax, dword ptr [esp + eax]
        0x4795f7: sub ebp, 4
        0x4795ff: mov dword ptr [ebp], eax
        0x47960e: mov eax, dword ptr [esi]
        0x479616: lea esi, [esi + 4]
        0x479623: xor eax, ebx
        0x479625: ror eax, 1
        0x47962e: xor eax, 0x4acb3db9
        0x479633: sub eax, 0x458c0140
        0x460927: rol eax, 1
        0x460929: xor ebx, eax
        0x46092b: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB88 -> 0x000000000047FB8D
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 45f457
basic block ends with indirect unconditional branch
basic block ends with indirect unconditional branch
        0x45f457: movzx eax, byte ptr [esi]
        0x45f45b: add esi, 1
        0x45f465: xor al, bl
        0x45f468: sub al, 0x3a
        0x45f46a: ror al, 1
        0x45f470: neg al
        0x46a3d7: not al
        0x46a3e0: xor bl, al
Load Scratch:[0xc]
        0x46a3e4: mov eax, dword ptr [esp + eax]
        0x46a3e8: lea ebp, [ebp - 4]
        0x46a3f1: mov dword ptr [ebp], eax
        0x46a3fa: mov eax, dword ptr [esi]
        0x46a403: add esi, 4
        0x46a409: xor eax, ebx
        0x46a40c: ror eax, 1
        0x46a417: xor eax, 0x4acb3db9
        0x46a424: sub eax, 0x458c0140
        0x46a42b: rol eax, 1
        0x46a432: xor ebx, eax
        0x46a434: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB8D -> 0x000000000047FB92
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 441cf6
        0x441cf6: movzx eax, byte ptr [esi]
        0x441d02: lea esi, [esi + 1]
        0x441d0f: xor al, bl
        0x441d13: sub al, 0x3a
        0x441d15: ror al, 1
        0x4596b9: neg al
        0x4596c0: not al
        0x4596c2: xor bl, al
Load Scratch:[0x14]
        0x4596cb: mov eax, dword ptr [esp + eax]
        0x4596d2: sub ebp, 4
        0x4596e2: mov dword ptr [ebp], eax
        0x4596ec: mov eax, dword ptr [esi]
        0x4596ee: add esi, 4
        0x4466ea: xor eax, ebx
        0x4466ec: ror eax, 1
        0x4466f3: xor eax, 0x4acb3db9
        0x4466f8: sub eax, 0x458c0140
        0x4466fe: rol eax, 1
        0x446700: xor ebx, eax
        0x446707: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB92 -> 0x000000000047FB97
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 437794
        0x437794: movzx eax, byte ptr [esi]
        0x437799: lea esi, [esi + 1]
        0x4377a7: xor al, bl
        0x4377aa: sub al, 0x3a
        0x4377ad: ror al, 1
        0x4377b3: neg al
        0x4377b5: not al
        0x4377bd: xor bl, al
Load Scratch:[0x30]
        0x4377c1: mov eax, dword ptr [esp + eax]
        0x4502ef: lea ebp, [ebp - 4]
        0x4502f5: mov dword ptr [ebp], eax
        0x4502f9: mov eax, dword ptr [esi]
        0x4502fe: add esi, 4
        0x450305: xor eax, ebx
        0x450308: ror eax, 1
        0x45030a: xor eax, 0x4acb3db9
        0x450310: sub eax, 0x458c0140
        0x449794: rol eax, 1
        0x4497a0: xor ebx, eax
        0x4497a2: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB97 -> 0x000000000047FB9C
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 438038
        0x438038: movzx eax, byte ptr [esi]
        0x43803c: add esi, 1
        0x438042: xor al, bl
        0x438046: sub al, 0x3a
        0x438049: ror al, 1
        0x43804e: neg al
        0x438056: not al
        0x43805a: xor bl, al
Load Scratch:[0x20]
        0x43805f: mov eax, dword ptr [esp + eax]
        0x438067: lea ebp, [ebp - 4]
        0x43806f: mov dword ptr [ebp], eax
        0x438073: mov eax, dword ptr [esi]
        0x460d5b: add esi, 4
        0x460d61: xor eax, ebx
        0x460d65: ror eax, 1
        0x460d6e: xor eax, 0x4acb3db9
        0x481c3e: sub eax, 0x458c0140
        0x481c43: rol eax, 1
        0x481c46: xor ebx, eax
        0x481c48: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FB9C -> 0x000000000047FBA1
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 43fc2a
        0x43fc2a: movzx eax, byte ptr [esi]
        0x43fc2f: lea esi, [esi + 1]
        0x43fc35: xor al, bl
        0x43fc3f: sub al, 0x3a
        0x43fc42: ror al, 1
        0x43fc44: neg al
        0x43fc4e: not al
        0x43fc54: xor bl, al
Load Scratch:[0x28]
        0x43fc57: mov eax, dword ptr [esp + eax]
        0x486f37: lea ebp, [ebp - 4]
        0x486f3d: mov dword ptr [ebp], eax
        0x486f41: mov eax, dword ptr [esi]
        0x486f46: add esi, 4
        0x486f4c: xor eax, ebx
        0x486f4e: ror eax, 1
        0x486f51: xor eax, 0x4acb3db9
        0x486f5d: sub eax, 0x458c0140
        0x486f63: rol eax, 1
        0x486f65: xor ebx, eax
        0x486f6d: add edi, eax
        0x44a8a7: lea eax, [esp + 0x60]
        0x44a8ac: cmp ebp, eax
        0x47f287: ja 0x4181bb
        0x4181bb: jmp edi
handlers outputs:
        bytecode: 0x000000000047FBA1 -> 0x000000000047FBA6
        sp: 0x0000000000000F40 -> 0x0000000000000F40
        stack: 0x0000000000001000 -> 0x0000000000000FFC
done.



start analyzing 4442f0
basic block ends with ret
        0x4442f0: mov esp, ebp
        0x4442f4: pop esi
        0x444300: pop edx
        0x444304: pop ebx
        0x444305: popfd
        0x44430a: pop edi
        0x444314: pop eax
        0x444315: pop ebp
        0x444316: pop ecx
        0x43f92a: ret
handlers outputs:
        bytecode: 0x000000000047FBA6 -> 0x0000000000001000
        sp: 0x0000000000000F40 -> 0x0000000000001024
        stack: 0x0000000000001000 -> 0x0000000000000000
done.



push Dword(0x9486CFEA)
push Dword(0x4869C5)
push ecx
push ebp
push eax
push edi
push eflags
push ebx
push edx
push esi
push Dword(0x0)
47fa63:
        t1(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x2c]=t1(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa68:
        t2(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x28]=t2(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa6d:
        t3(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x20]=t3(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa72:
        t4(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x30]=t4(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa77:
        t5(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x14]=t5(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa7c:
        t6(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0xc]=t6(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa81:
        t7(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x10]=t7(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa86:
        t8(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x0]=t8(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa8b:
        t9(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x4]=t9(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa90:
        t10(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x34]=t10(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa95:
        t11(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x34]=t11(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fa9a:
        t12(4bytes)=dword ptr scratch:[0x0]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t12(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fa9f:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=STACK(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47faa3:
        t13(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x18]=t13(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47faa8:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x200
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fab0:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=STACK(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fab4:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x4
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fabc:
        t14(4bytes)=[SP+0x0](4bytes)
        t15(4bytes)=[SP+0x4](4bytes)
        t16(4bytes)=Add(t14(4bytes), t15(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t16(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fac0:
        t17(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x38]=t17(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fac5:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=STACK(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fac9:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x8
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fad1:
        t18(4bytes)=[SP+0x0](4bytes)
        t19(4bytes)=[SP+0x4](4bytes)
        t20(4bytes)=Add(t18(4bytes), t19(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t20(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fad5:
        t21(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x38]=t21(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fada:
        t22(4bytes)=[SP+0x0](4bytes)
        t23(4bytes)=[SP+0x4](4bytes)
        t24(4bytes)=Not(t22(4bytes))
        t25(4bytes)=Not(t23(4bytes))
        t26(4bytes)=And(t24(4bytes), t25(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t26(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fade:
        t27(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x24]=t27(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fae3:
        t28(4bytes)=[SP+0x0](4bytes)
        t29(4bytes)=[SP+0x4](4bytes)
        t30(4bytes)=Add(t28(4bytes), t29(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t30(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fae7:
        t31(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x24]=t31(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47faec:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=STACK(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47faf0:
        t32(4bytes)=[SP+0x0](4bytes)
        t33(4bytes)=Deref(ss, t32(4bytes), dword)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=t33(4bytes)
47faf4:
        t34(4bytes)=[SP+0x0](4bytes)
        t35(4bytes)=[SP+0x4](4bytes)
        t36(4bytes)=Not(t34(4bytes))
        t37(4bytes)=Not(t35(4bytes))
        t38(4bytes)=And(t36(4bytes), t37(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t38(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47faf8:
        t39(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x8]=t39(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fafd:
        t40(4bytes)=[SP+0x0](4bytes)
        t41(4bytes)=Cmp(t40(4bytes), 0xfa0)
47fb01:
        t42(4bytes)=dword ptr scratch:[0x24]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t42(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb06:
        t43(4bytes)=dword ptr scratch:[0x24]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t43(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb0b:
        t44(4bytes)=[SP+0x0](4bytes)
        t45(4bytes)=[SP+0x4](4bytes)
        t46(4bytes)=Not(t44(4bytes))
        t47(4bytes)=Not(t45(4bytes))
        t48(4bytes)=And(t46(4bytes), t47(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t48(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb0f:
        t49(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x38]=t49(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb14:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0xfffff7ea
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb1c:
        t50(4bytes)=[SP+0x0](4bytes)
        t51(4bytes)=[SP+0x4](4bytes)
        t52(4bytes)=Not(t50(4bytes))
        t53(4bytes)=Not(t51(4bytes))
        t54(4bytes)=And(t52(4bytes), t53(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t54(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb20:
        t55(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x1c]=t55(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb25:
        t56(4bytes)=dword ptr scratch:[0x8]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t56(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb2a:
        t57(4bytes)=dword ptr scratch:[0x8]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t57(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb2f:
        t58(4bytes)=[SP+0x0](4bytes)
        t59(4bytes)=[SP+0x4](4bytes)
        t60(4bytes)=Not(t58(4bytes))
        t61(4bytes)=Not(t59(4bytes))
        t62(4bytes)=And(t60(4bytes), t61(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t62(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb33:
        t63(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x38]=t63(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb38:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x815
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb40:
        t64(4bytes)=[SP+0x0](4bytes)
        t65(4bytes)=[SP+0x4](4bytes)
        t66(4bytes)=Not(t64(4bytes))
        t67(4bytes)=Not(t65(4bytes))
        t68(4bytes)=And(t66(4bytes), t67(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t68(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb44:
        t69(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x1c]=t69(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb49:
        t70(4bytes)=[SP+0x0](4bytes)
        t71(4bytes)=[SP+0x4](4bytes)
        t72(4bytes)=Add(t70(4bytes), t71(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t72(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb4d:
        t73(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x3c]=t73(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb52:
        t74(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x14]=t74(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb57:
        t75(4bytes)=dword ptr scratch:[0x28]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t75(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb5c:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x4312d7
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb64:
        t76(4bytes)=dword ptr scratch:[0x2c]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t76(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb69:
        t77(4bytes)=[SP+0x0](4bytes)
        t78(4bytes)=[SP+0x4](4bytes)
        t79(4bytes)=Add(t77(4bytes), t78(4bytes))
        dword ptr regular:[Add(STACK(4bytes), 0x4)]=t79(4bytes)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=eflags
47fb6d:
        t80(4bytes)=[SP+0x0](4bytes)
        dword ptr scratch:[0x38]=t80(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0x4)
47fb72:
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=0x40e068
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb7a:
        t81(4bytes)=[SP+0x0](4bytes)
        t82(4bytes)=Deref(regular, t81(4bytes), dword)
        dword ptr regular:[Add(STACK(4bytes), 0x0)]=t82(4bytes)
47fb7e:
        t83(4bytes)=dword ptr scratch:[0x4]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t83(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb83:
        t84(4bytes)=dword ptr scratch:[0x18]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t84(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb88:
        t85(4bytes)=dword ptr scratch:[0x10]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t85(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb8d:
        t86(4bytes)=dword ptr scratch:[0xc]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t86(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb92:
        t87(4bytes)=dword ptr scratch:[0x14]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t87(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb97:
        t88(4bytes)=dword ptr scratch:[0x30]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t88(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fb9c:
        t89(4bytes)=dword ptr scratch:[0x20]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t89(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fba1:
        t90(4bytes)=dword ptr scratch:[0x28]
        dword ptr regular:[Add(STACK(4bytes), 0xfffffffffffffffc)]=t90(4bytes)
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffffffc)
47fba6:
        STACK(4bytes)=Add(STACK(4bytes), 0xfffffffffffff000)


C:\Users\Lily\source\repos\VMProtectTest\x64\Release\VMProtectTest.exe ( 15896)  0 
...
